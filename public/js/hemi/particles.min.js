/*
 * Port of O3D's gpu-enabled particle system to Three.js with minor modifications.
 * @author Erik Kitson
 */

/*
 * Copyright 2009, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var hemi=function(a){a.particles=a.particles||{};var b=function(a){var b=new Uint8Array(a.length),c;for(var d=0;d<a.length;++d)c=a[d]*256,b[d]=c>255?255:c<0?0:c;return b},c={particle3d:{attributes:{uvLifeTimeFrameStart:{type:"v4",value:[]},positionStartTime:{type:"v4",value:[]},velocityStartSize:{type:"v4",value:[]},accelerationEndSize:{type:"v4",value:[]},spinStartSpinSpeed:{type:"v4",value:[]},orientation:{type:"v4",value:[]},colorMult:{type:"v4",value:[]}},uniforms:{worldVelocity:{type:"v3",value:new THREE.Vector3},worldAcceleration:{type:"v3",value:new THREE.Vector3},timeRange:{type:"f",value:0},time:{type:"f",value:0},timeOffset:{type:"f",value:0},frameDuration:{type:"f",value:0},numFrames:{type:"f",value:0},rampSampler:{type:"t",value:0,texture:null},colorSampler:{type:"t",value:1,texture:null}},vertexShader:"uniform vec3 worldVelocity;\nuniform vec3 worldAcceleration;\nuniform float timeRange;\nuniform float time;\nuniform float timeOffset;\nuniform float frameDuration;\nuniform float numFrames;\n\nattribute vec4 uvLifeTimeFrameStart; \nattribute vec4 positionStartTime; \nattribute vec4 velocityStartSize; \nattribute vec4 accelerationEndSize; \nattribute vec4 spinStartSpinSpeed; \nattribute vec4 orientation; \nattribute vec4 colorMult; \n\nvarying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\n\nvoid main() {\n  vec2 uv = uvLifeTimeFrameStart.xy;\n  float lifeTime = uvLifeTimeFrameStart.z;\n  float frameStart = uvLifeTimeFrameStart.w;\n  vec3 position = positionStartTime.xyz;\n  float startTime = positionStartTime.w;\n  vec3 velocity = (objectMatrix * vec4(velocityStartSize.xyz, 0)).xyz\n      + worldVelocity;\n  float startSize = velocityStartSize.w;\n  vec3 acceleration = (objectMatrix *\n      vec4(accelerationEndSize.xyz, 0)).xyz + worldAcceleration;\n  float endSize = accelerationEndSize.w;\n  float spinStart = spinStartSpinSpeed.x;\n  float spinSpeed = spinStartSpinSpeed.y;\n\n  float localTime = mod((time - timeOffset - startTime),\n      timeRange);\n  float percentLife = localTime / lifeTime;\n\n  float frame = mod(floor(localTime / frameDuration + frameStart),\n                     numFrames);\n  float uOffset = frame / numFrames;\n  float u = uOffset + (uv.x + 0.5) * (1.0 / numFrames);\n\n  v_texcoord = vec2(u, uv.y + 0.5);\n  v_colorMult = colorMult;\n\n  float size = mix(startSize, endSize, percentLife);\n  size = (percentLife < 0.0 || percentLife > 1.0) ? 0.0 : size;\n  float s = sin(spinStart + spinSpeed * localTime);\n  float c = cos(spinStart + spinSpeed * localTime);\n\n  vec4 rotatedPoint = vec4((uv.x * c + uv.y * s) * size, 0.0,\n                               (uv.x * s - uv.y * c) * size, 1.0);\n  vec3 center = velocity * localTime +\n                  acceleration * localTime * localTime + \n                  position;\n  \n      vec4 q2 = orientation + orientation;\n      vec4 qx = orientation.xxxw * q2.xyzx;\n      vec4 qy = orientation.xyyw * q2.xyzy;\n      vec4 qz = orientation.xxzw * q2.xxzz;\n  \n      mat4 localMatrix = mat4(\n        (1.0 - qy.y) - qz.z, \n        qx.y + qz.w, \n        qx.z - qy.w,\n        0,\n  \n        qx.y - qz.w, \n        (1.0 - qx.x) - qz.z, \n        qy.z + qx.w,\n        0,\n  \n        qx.z + qy.w, \n        qy.z - qx.w, \n        (1.0 - qx.x) - qy.y,\n        0,\n  \n        center.x, center.y, center.z, 1.0);\n  rotatedPoint = localMatrix * rotatedPoint;\n  gl_Position = projectionMatrix * modelViewMatrix * rotatedPoint;\n  v_percentLife = percentLife;\n}\n",fragmentShader:"varying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\n\n// We need to implement 1D!\nuniform sampler2D rampSampler;\nuniform sampler2D colorSampler;\n\nvoid main() {\n  vec4 colorMult = texture2D(rampSampler, \n      vec2(v_percentLife, 0.5)) * v_colorMult;\n  vec4 color = texture2D(colorSampler, v_texcoord) * colorMult;\n  gl_FragColor = color;\n}\n"},particle2d:{attributes:{uvLifeTimeFrameStart:{type:"v4",value:[]},positionStartTime:{type:"v4",value:[]},velocityStartSize:{type:"v4",value:[]},accelerationEndSize:{type:"v4",value:[]},spinStartSpinSpeed:{type:"v4",value:[]},colorMult:{type:"v4",value:[]}},uniforms:{viewInverse:{type:"m4",value:null},worldVelocity:{type:"v3",value:new THREE.Vector3},worldAcceleration:{type:"v3",value:new THREE.Vector3},timeRange:{type:"f",value:0},time:{type:"f",value:0},timeOffset:{type:"f",value:0},frameDuration:{type:"f",value:0},numFrames:{type:"f",value:0},rampSampler:{type:"t",value:0,texture:null},colorSampler:{type:"t",value:1,texture:null}},vertexShader:"uniform mat4 viewInverse;\nuniform vec3 worldVelocity;\nuniform vec3 worldAcceleration;\nuniform float timeRange;\nuniform float time;\nuniform float timeOffset;\nuniform float frameDuration;\nuniform float numFrames;\n\nattribute vec4 uvLifeTimeFrameStart; \nattribute vec4 positionStartTime; \nattribute vec4 velocityStartSize; \nattribute vec4 accelerationEndSize; \nattribute vec4 spinStartSpinSpeed; \nattribute vec4 colorMult; \n\nvarying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\n\nvoid main() {\n  vec2 uv = uvLifeTimeFrameStart.xy;\n  float lifeTime = uvLifeTimeFrameStart.z;\n  float frameStart = uvLifeTimeFrameStart.w;\n  vec3 position = (objectMatrix * vec4(positionStartTime.xyz, 1.0)).xyz;\n  float startTime = positionStartTime.w;\n  vec3 velocity = (objectMatrix * vec4(velocityStartSize.xyz, 0)).xyz \n      + worldVelocity;\n  float startSize = velocityStartSize.w;\n  vec3 acceleration = (objectMatrix *\n      vec4(accelerationEndSize.xyz, 0)).xyz + worldAcceleration;\n  float endSize = accelerationEndSize.w;\n  float spinStart = spinStartSpinSpeed.x;\n  float spinSpeed = spinStartSpinSpeed.y;\n\n  float localTime = mod((time - timeOffset - startTime),\n      timeRange);\n  float percentLife = localTime / lifeTime;\n\n  float frame = mod(floor(localTime / frameDuration + frameStart),\n                     numFrames);\n  float uOffset = frame / numFrames;\n  float u = uOffset + (uv.x + 0.5) * (1.0 / numFrames);\n\n  v_texcoord = vec2(u, uv.y + 0.5);\n  v_colorMult = colorMult;\n\n  vec3 basisX = viewInverse[0].xyz;\n  vec3 basisZ = viewInverse[1].xyz;\n\n  float size = mix(startSize, endSize, percentLife);\n  size = (percentLife < 0.0 || percentLife > 1.0) ? 0.0 : size;\n  float s = sin(spinStart + spinSpeed * localTime);\n  float c = cos(spinStart + spinSpeed * localTime);\n\n  vec2 rotatedPoint = vec2(uv.x * c + uv.y * s, \n                               -uv.x * s + uv.y * c);\n  vec3 localPosition = vec3(basisX * rotatedPoint.x +\n                                basisZ * rotatedPoint.y) * size +\n                         velocity * localTime +\n                         acceleration * localTime * localTime + \n                         position;\n\n  gl_Position = (projectionMatrix * viewMatrix * vec4(localPosition, 1.0));\n  v_percentLife = percentLife;\n}\n",fragmentShader:"varying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\n\n// We need to implement 1D!\nuniform sampler2D rampSampler;\nuniform sampler2D colorSampler;\n\nvoid main() {\n  vec4 colorMult = texture2D(rampSampler, \n      vec2(v_percentLife, 0.5)) * v_colorMult;\n  vec4 color = texture2D(colorSampler, v_texcoord) * colorMult;\n  gl_FragColor = color;\n}\n"}},d=[[-0.5,-0.5],[.5,-0.5],[.5,.5],[-0.5,.5]];a.particles.System=function(a){var c=[0,.2,.7,1,.7,.2,0,0],d=[];for(var e=0;e<8;++e)for(var f=0;f<8;++f){var g=c[f]*c[e];d.push(g,g,g,g)}var h=b(d),i=new THREE.DataTexture(h,8,8,THREE.RGBAFormat),j=b([1,1,1,1,1,1,1,.5,1,1,1,0]),k=new THREE.DataTexture(j,3,1,THREE.RGBAFormat);i.needsUpdate=k.needsUpdate=!0,this._randomFunction=a||function(){return Math.random()},this.defaultColorTexture=i,this.defaultRampTexture=k,this.emitters=[]},a.particles.System.prototype.createEmitter=function(b,c){return new a.particles.Emitter(this,b,c)},a.particles.System.prototype.createTrail=function(b,c,d,e,f){return new a.particles.Trail(this,b,c,d,e,f)},a.particles.System.prototype.update=function(a){for(var b=0,c=this.emitters.length;b<c;++b)this.emitters[b]._timeParam.value+=a},a.particles.Spec=function(){this.numParticles=1,this.numFrames=1,this.frameDuration=1,this.frameStart=0,this.frameStartRange=0,this.timeRange=99999999,this.startTime=null,this.lifeTime=1,this.lifeTimeRange=0,this.startSize=1,this.startSizeRange=0,this.endSize=1,this.endSizeRange=0,this.position=[0,0,0],this.positionRange=[0,0,0],this.velocity=[0,0,0],this.velocityRange=[0,0,0],this.acceleration=[0,0,0],this.accelerationRange=[0,0,0],this.spinStart=0,this.spinStartRange=0,this.spinSpeed=0,this.spinSpeedRange=0,this.colorMult=[1,1,1,1],this.colorMultRange=[0,0,0,0],this.worldVelocity=[0,0,0],this.worldAcceleration=[0,0,0],this.billboard=!0,this.orientation=[0,0,0,1]},a.particles.Emitter=function(a,b,c){this._camera=b,this._colorTexture=c||null,this._particleSystem=null,this._rampTexture=null,this._timeParam=null,this.material=new THREE.ShaderMaterial({blending:THREE.AdditiveBlending,depthWrite:!1,transparent:!0}),this.material.name="particles",this.shape=new THREE.Geometry,a&&(this._colorTexture=c||a.defaultColorTexture,this._rampTexture=a.defaultRampTexture,this._particleSystem=a,a.emitters.push(this))},a.particles.Emitter.prototype.setBlending=function(a){this.material.blending=a},a.particles.Emitter.prototype.setColorRamp=function(c){var d=c.length/4;d%1!==0&&a.error("colorRamp must have multiple of 4 entries");var e=b(c);this._rampTexture===this._particleSystem.defaultRampTexture||this._rampTexture.image.width!==d?(this._rampTexture=new THREE.DataTexture(e,d,1,THREE.RGBAFormat),this._rampTexture.needsUpdate=!0,this.uniforms&&(this.uniforms.rampSampler.texture=this._rampTexture)):this._rampTexture.image.data=e},a.particles.Emitter.prototype.validateParameters=function(b){var c=new a.particles.Spec;for(var d in b)typeof c[d]=="undefined"&&a.error('unknown particle parameter "'+d+'"');for(d in c)typeof b[d]=="undefined"&&(b[d]=c[d])},a.particles.Emitter.prototype.setParameters=function(a,b){g.call(this,a);var c=a.numParticles;e.call(this,c),f.call(this,0,c,a,b)},a.particles.Emitter.prototype.createOneShot=function(b){return new a.particles.OneShot(this,b)},a.particles.OneShot=function(a,b){this._emitter=a,this._timeOffsetParam=a.material.uniforms.timeOffset,this.transform=new THREE.Mesh(a.shape,a.material),this.transform.visible=!1,b&&b.add(this.transform)},a.particles.OneShot.prototype.trigger=function(a,b){b&&b.add(this._transform),a&&this._transform.position.copy(a),this._transform.visible=!0,this._timeOffsetParam.value=this._emitter._timeParam.value},a.particles.Trail=function(b,c,d,f,h,i){a.particles.Emitter.call(this,b,c,h),this._birthIndex=0,this._maxParticles=d,this._parameters=f,this._paramSetter=i,e.call(this,d),g.call(this,f)},a.particles.Trail.prototype=new a.particles.Emitter,a.particles.Trail.constructor=a.particles.Trail,a.particles.Trail.prototype.birthParticles=function(a){var b=this._parameters.numParticles;this._parameters.startTime=this._timeParam.value,this._parameters.position=a;while(this._birthIndex+b>=this._maxParticles){var c=this._maxParticles-this._birthIndex;f.call(this,this._birthIndex,c,this._parameters,this._paramSetter),b-=c,this._birthIndex=0}f.call(this,this._birthIndex,b,this._parameters,this._paramSetter),this._birthIndex+=b};var e=function(a){for(var b=0;b<a;++b){for(var c=0;c<4;++c)this.shape.vertices.push(new THREE.Vertex);var d=b*4;this.shape.faces.push(new THREE.Face3(d,d+1,d+2)),this.shape.faces.push(new THREE.Face3(d,d+2,d+3))}},f=function(a,b,c,e){var f=this.material.attributes,g=this.material.uniforms,h=f.uvLifeTimeFrameStart;positionStartTime=f.positionStartTime,velocityStartSize=f.velocityStartSize,accelerationEndSize=f.accelerationEndSize,spinStartSpinSpeed=f.spinStartSpinSpeed,orientation=f.orientation,colorMult=f.colorMult,wv=c.worldVelocity,wa=c.worldAcceleration,random=this._particleSystem._randomFunction,plusMinus=function(a){return(random()-.5)*a*2},plusMinusVector=function(a,b){var c=[];for(var d=0,e=a.length;d<e;++d)c[d]=a[d]+plusMinus(b[d]);return c},g.colorSampler.texture=this._colorTexture,g.rampSampler.texture=this._rampTexture,g.timeRange.value=c.timeRange,g.numFrames.value=c.numFrames,g.frameDuration.value=c.frameDuration,g.worldVelocity.value.set(wv[0],wv[1],wv[2]),g.worldAcceleration.value.set(wa[0],wa[1],wa[2]),c.billboard&&(g.viewInverse.value=this._camera.matrixWorld);for(var i=0;i<b;++i){e&&e(i,c);var j=c.lifeTime,k=c.startTime===null?i*j/b:c.startTime,l=c.frameStart+plusMinus(c.frameStartRange),m=plusMinusVector(c.position,c.positionRange),n=plusMinusVector(c.velocity,c.velocityRange),o=plusMinusVector(c.acceleration,c.accelerationRange),p=plusMinusVector(c.colorMult,c.colorMultRange),q=c.spinStart+plusMinus(c.spinStartRange),r=c.spinSpeed+plusMinus(c.spinSpeedRange),s=c.startSize+plusMinus(c.startSizeRange),t=c.endSize+plusMinus(c.endSizeRange),u=c.orientation;for(var v=0;v<4;++v){var w=i*4+v+a;h.value[w]=new THREE.Vector4(d[v][0],d[v][1],j,l),positionStartTime.value[w]=new THREE.Vector4(m[0],m[1],m[2],k),velocityStartSize.value[w]=new THREE.Vector4(n[0],n[1],n[2],s),accelerationEndSize.value[w]=new THREE.Vector4(o[0],o[1],o[2],t),spinStartSpinSpeed.value[w]=new THREE.Vector4(q,r,0,0),colorMult.value[w]=new THREE.Vector4(p[0],p[1],p[2],p[3]),orientation&&(orientation.value[w]=new THREE.Vector4(u[0],u[1],u[2],u[3]))}}h.needsUpdate=!0,positionStartTime.needsUpdate=!0,velocityStartSize.needsUpdate=!0,accelerationEndSize.needsUpdate=!0,spinStartSpinSpeed.needsUpdate=!0,colorMult.needsUpdate=!0,orientation&&(orientation.needsUpdate=!0)},g=function(a){this.validateParameters(a);var b=c[a.billboard?"particle2d":"particle3d"];this.material.attributes=THREE.UniformsUtils.clone(b.attributes),this.material.uniforms=THREE.UniformsUtils.clone(b.uniforms),this.material.vertexShader=b.vertexShader,this.material.fragmentShader=b.fragmentShader,this._timeParam=this.material.uniforms.time};return a}(hemi||{})